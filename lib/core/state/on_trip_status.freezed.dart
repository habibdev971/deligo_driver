// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'on_trip_status.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$OnTripStatusState<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() goForPickup,
    required TResult Function() arrivedAtPickupPoint,
    required TResult Function() rideStarted,
    required TResult Function() headingToDestination,
    required TResult Function() reachedDestination,
    required TResult Function() payment,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? goForPickup,
    TResult? Function()? arrivedAtPickupPoint,
    TResult? Function()? rideStarted,
    TResult? Function()? headingToDestination,
    TResult? Function()? reachedDestination,
    TResult? Function()? payment,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? goForPickup,
    TResult Function()? arrivedAtPickupPoint,
    TResult Function()? rideStarted,
    TResult Function()? headingToDestination,
    TResult Function()? reachedDestination,
    TResult Function()? payment,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(_GoForPickup<T> value) goForPickup,
    required TResult Function(_ArrivedAtPickupPoint<T> value)
    arrivedAtPickupPoint,
    required TResult Function(_RideStarted<T> value) rideStarted,
    required TResult Function(_HeadingToDestination<T> value)
    headingToDestination,
    required TResult Function(_ReachedDestination<T> value) reachedDestination,
    required TResult Function(_Payment<T> value) payment,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(_GoForPickup<T> value)? goForPickup,
    TResult? Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult? Function(_RideStarted<T> value)? rideStarted,
    TResult? Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult? Function(_ReachedDestination<T> value)? reachedDestination,
    TResult? Function(_Payment<T> value)? payment,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(_GoForPickup<T> value)? goForPickup,
    TResult Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult Function(_RideStarted<T> value)? rideStarted,
    TResult Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult Function(_ReachedDestination<T> value)? reachedDestination,
    TResult Function(_Payment<T> value)? payment,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OnTripStatusStateCopyWith<T, $Res> {
  factory $OnTripStatusStateCopyWith(
    OnTripStatusState<T> value,
    $Res Function(OnTripStatusState<T>) then,
  ) = _$OnTripStatusStateCopyWithImpl<T, $Res, OnTripStatusState<T>>;
}

/// @nodoc
class _$OnTripStatusStateCopyWithImpl<
  T,
  $Res,
  $Val extends OnTripStatusState<T>
>
    implements $OnTripStatusStateCopyWith<T, $Res> {
  _$OnTripStatusStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OnTripStatusState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<T, $Res> {
  factory _$$InitialImplCopyWith(
    _$InitialImpl<T> value,
    $Res Function(_$InitialImpl<T>) then,
  ) = __$$InitialImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<T, $Res>
    extends _$OnTripStatusStateCopyWithImpl<T, $Res, _$InitialImpl<T>>
    implements _$$InitialImplCopyWith<T, $Res> {
  __$$InitialImplCopyWithImpl(
    _$InitialImpl<T> _value,
    $Res Function(_$InitialImpl<T>) _then,
  ) : super(_value, _then);

  /// Create a copy of OnTripStatusState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl<T> implements _Initial<T> {
  const _$InitialImpl();

  @override
  String toString() {
    return 'OnTripStatusState<$T>.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() goForPickup,
    required TResult Function() arrivedAtPickupPoint,
    required TResult Function() rideStarted,
    required TResult Function() headingToDestination,
    required TResult Function() reachedDestination,
    required TResult Function() payment,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? goForPickup,
    TResult? Function()? arrivedAtPickupPoint,
    TResult? Function()? rideStarted,
    TResult? Function()? headingToDestination,
    TResult? Function()? reachedDestination,
    TResult? Function()? payment,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? goForPickup,
    TResult Function()? arrivedAtPickupPoint,
    TResult Function()? rideStarted,
    TResult Function()? headingToDestination,
    TResult Function()? reachedDestination,
    TResult Function()? payment,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(_GoForPickup<T> value) goForPickup,
    required TResult Function(_ArrivedAtPickupPoint<T> value)
    arrivedAtPickupPoint,
    required TResult Function(_RideStarted<T> value) rideStarted,
    required TResult Function(_HeadingToDestination<T> value)
    headingToDestination,
    required TResult Function(_ReachedDestination<T> value) reachedDestination,
    required TResult Function(_Payment<T> value) payment,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(_GoForPickup<T> value)? goForPickup,
    TResult? Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult? Function(_RideStarted<T> value)? rideStarted,
    TResult? Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult? Function(_ReachedDestination<T> value)? reachedDestination,
    TResult? Function(_Payment<T> value)? payment,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(_GoForPickup<T> value)? goForPickup,
    TResult Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult Function(_RideStarted<T> value)? rideStarted,
    TResult Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult Function(_ReachedDestination<T> value)? reachedDestination,
    TResult Function(_Payment<T> value)? payment,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial<T> implements OnTripStatusState<T> {
  const factory _Initial() = _$InitialImpl<T>;
}

/// @nodoc
abstract class _$$GoForPickupImplCopyWith<T, $Res> {
  factory _$$GoForPickupImplCopyWith(
    _$GoForPickupImpl<T> value,
    $Res Function(_$GoForPickupImpl<T>) then,
  ) = __$$GoForPickupImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$GoForPickupImplCopyWithImpl<T, $Res>
    extends _$OnTripStatusStateCopyWithImpl<T, $Res, _$GoForPickupImpl<T>>
    implements _$$GoForPickupImplCopyWith<T, $Res> {
  __$$GoForPickupImplCopyWithImpl(
    _$GoForPickupImpl<T> _value,
    $Res Function(_$GoForPickupImpl<T>) _then,
  ) : super(_value, _then);

  /// Create a copy of OnTripStatusState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GoForPickupImpl<T> implements _GoForPickup<T> {
  const _$GoForPickupImpl();

  @override
  String toString() {
    return 'OnTripStatusState<$T>.goForPickup()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GoForPickupImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() goForPickup,
    required TResult Function() arrivedAtPickupPoint,
    required TResult Function() rideStarted,
    required TResult Function() headingToDestination,
    required TResult Function() reachedDestination,
    required TResult Function() payment,
  }) {
    return goForPickup();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? goForPickup,
    TResult? Function()? arrivedAtPickupPoint,
    TResult? Function()? rideStarted,
    TResult? Function()? headingToDestination,
    TResult? Function()? reachedDestination,
    TResult? Function()? payment,
  }) {
    return goForPickup?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? goForPickup,
    TResult Function()? arrivedAtPickupPoint,
    TResult Function()? rideStarted,
    TResult Function()? headingToDestination,
    TResult Function()? reachedDestination,
    TResult Function()? payment,
    required TResult orElse(),
  }) {
    if (goForPickup != null) {
      return goForPickup();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(_GoForPickup<T> value) goForPickup,
    required TResult Function(_ArrivedAtPickupPoint<T> value)
    arrivedAtPickupPoint,
    required TResult Function(_RideStarted<T> value) rideStarted,
    required TResult Function(_HeadingToDestination<T> value)
    headingToDestination,
    required TResult Function(_ReachedDestination<T> value) reachedDestination,
    required TResult Function(_Payment<T> value) payment,
  }) {
    return goForPickup(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(_GoForPickup<T> value)? goForPickup,
    TResult? Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult? Function(_RideStarted<T> value)? rideStarted,
    TResult? Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult? Function(_ReachedDestination<T> value)? reachedDestination,
    TResult? Function(_Payment<T> value)? payment,
  }) {
    return goForPickup?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(_GoForPickup<T> value)? goForPickup,
    TResult Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult Function(_RideStarted<T> value)? rideStarted,
    TResult Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult Function(_ReachedDestination<T> value)? reachedDestination,
    TResult Function(_Payment<T> value)? payment,
    required TResult orElse(),
  }) {
    if (goForPickup != null) {
      return goForPickup(this);
    }
    return orElse();
  }
}

abstract class _GoForPickup<T> implements OnTripStatusState<T> {
  const factory _GoForPickup() = _$GoForPickupImpl<T>;
}

/// @nodoc
abstract class _$$ArrivedAtPickupPointImplCopyWith<T, $Res> {
  factory _$$ArrivedAtPickupPointImplCopyWith(
    _$ArrivedAtPickupPointImpl<T> value,
    $Res Function(_$ArrivedAtPickupPointImpl<T>) then,
  ) = __$$ArrivedAtPickupPointImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$ArrivedAtPickupPointImplCopyWithImpl<T, $Res>
    extends
        _$OnTripStatusStateCopyWithImpl<T, $Res, _$ArrivedAtPickupPointImpl<T>>
    implements _$$ArrivedAtPickupPointImplCopyWith<T, $Res> {
  __$$ArrivedAtPickupPointImplCopyWithImpl(
    _$ArrivedAtPickupPointImpl<T> _value,
    $Res Function(_$ArrivedAtPickupPointImpl<T>) _then,
  ) : super(_value, _then);

  /// Create a copy of OnTripStatusState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ArrivedAtPickupPointImpl<T> implements _ArrivedAtPickupPoint<T> {
  const _$ArrivedAtPickupPointImpl();

  @override
  String toString() {
    return 'OnTripStatusState<$T>.arrivedAtPickupPoint()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ArrivedAtPickupPointImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() goForPickup,
    required TResult Function() arrivedAtPickupPoint,
    required TResult Function() rideStarted,
    required TResult Function() headingToDestination,
    required TResult Function() reachedDestination,
    required TResult Function() payment,
  }) {
    return arrivedAtPickupPoint();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? goForPickup,
    TResult? Function()? arrivedAtPickupPoint,
    TResult? Function()? rideStarted,
    TResult? Function()? headingToDestination,
    TResult? Function()? reachedDestination,
    TResult? Function()? payment,
  }) {
    return arrivedAtPickupPoint?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? goForPickup,
    TResult Function()? arrivedAtPickupPoint,
    TResult Function()? rideStarted,
    TResult Function()? headingToDestination,
    TResult Function()? reachedDestination,
    TResult Function()? payment,
    required TResult orElse(),
  }) {
    if (arrivedAtPickupPoint != null) {
      return arrivedAtPickupPoint();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(_GoForPickup<T> value) goForPickup,
    required TResult Function(_ArrivedAtPickupPoint<T> value)
    arrivedAtPickupPoint,
    required TResult Function(_RideStarted<T> value) rideStarted,
    required TResult Function(_HeadingToDestination<T> value)
    headingToDestination,
    required TResult Function(_ReachedDestination<T> value) reachedDestination,
    required TResult Function(_Payment<T> value) payment,
  }) {
    return arrivedAtPickupPoint(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(_GoForPickup<T> value)? goForPickup,
    TResult? Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult? Function(_RideStarted<T> value)? rideStarted,
    TResult? Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult? Function(_ReachedDestination<T> value)? reachedDestination,
    TResult? Function(_Payment<T> value)? payment,
  }) {
    return arrivedAtPickupPoint?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(_GoForPickup<T> value)? goForPickup,
    TResult Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult Function(_RideStarted<T> value)? rideStarted,
    TResult Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult Function(_ReachedDestination<T> value)? reachedDestination,
    TResult Function(_Payment<T> value)? payment,
    required TResult orElse(),
  }) {
    if (arrivedAtPickupPoint != null) {
      return arrivedAtPickupPoint(this);
    }
    return orElse();
  }
}

abstract class _ArrivedAtPickupPoint<T> implements OnTripStatusState<T> {
  const factory _ArrivedAtPickupPoint() = _$ArrivedAtPickupPointImpl<T>;
}

/// @nodoc
abstract class _$$RideStartedImplCopyWith<T, $Res> {
  factory _$$RideStartedImplCopyWith(
    _$RideStartedImpl<T> value,
    $Res Function(_$RideStartedImpl<T>) then,
  ) = __$$RideStartedImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$RideStartedImplCopyWithImpl<T, $Res>
    extends _$OnTripStatusStateCopyWithImpl<T, $Res, _$RideStartedImpl<T>>
    implements _$$RideStartedImplCopyWith<T, $Res> {
  __$$RideStartedImplCopyWithImpl(
    _$RideStartedImpl<T> _value,
    $Res Function(_$RideStartedImpl<T>) _then,
  ) : super(_value, _then);

  /// Create a copy of OnTripStatusState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$RideStartedImpl<T> implements _RideStarted<T> {
  const _$RideStartedImpl();

  @override
  String toString() {
    return 'OnTripStatusState<$T>.rideStarted()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RideStartedImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() goForPickup,
    required TResult Function() arrivedAtPickupPoint,
    required TResult Function() rideStarted,
    required TResult Function() headingToDestination,
    required TResult Function() reachedDestination,
    required TResult Function() payment,
  }) {
    return rideStarted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? goForPickup,
    TResult? Function()? arrivedAtPickupPoint,
    TResult? Function()? rideStarted,
    TResult? Function()? headingToDestination,
    TResult? Function()? reachedDestination,
    TResult? Function()? payment,
  }) {
    return rideStarted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? goForPickup,
    TResult Function()? arrivedAtPickupPoint,
    TResult Function()? rideStarted,
    TResult Function()? headingToDestination,
    TResult Function()? reachedDestination,
    TResult Function()? payment,
    required TResult orElse(),
  }) {
    if (rideStarted != null) {
      return rideStarted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(_GoForPickup<T> value) goForPickup,
    required TResult Function(_ArrivedAtPickupPoint<T> value)
    arrivedAtPickupPoint,
    required TResult Function(_RideStarted<T> value) rideStarted,
    required TResult Function(_HeadingToDestination<T> value)
    headingToDestination,
    required TResult Function(_ReachedDestination<T> value) reachedDestination,
    required TResult Function(_Payment<T> value) payment,
  }) {
    return rideStarted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(_GoForPickup<T> value)? goForPickup,
    TResult? Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult? Function(_RideStarted<T> value)? rideStarted,
    TResult? Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult? Function(_ReachedDestination<T> value)? reachedDestination,
    TResult? Function(_Payment<T> value)? payment,
  }) {
    return rideStarted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(_GoForPickup<T> value)? goForPickup,
    TResult Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult Function(_RideStarted<T> value)? rideStarted,
    TResult Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult Function(_ReachedDestination<T> value)? reachedDestination,
    TResult Function(_Payment<T> value)? payment,
    required TResult orElse(),
  }) {
    if (rideStarted != null) {
      return rideStarted(this);
    }
    return orElse();
  }
}

abstract class _RideStarted<T> implements OnTripStatusState<T> {
  const factory _RideStarted() = _$RideStartedImpl<T>;
}

/// @nodoc
abstract class _$$HeadingToDestinationImplCopyWith<T, $Res> {
  factory _$$HeadingToDestinationImplCopyWith(
    _$HeadingToDestinationImpl<T> value,
    $Res Function(_$HeadingToDestinationImpl<T>) then,
  ) = __$$HeadingToDestinationImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$HeadingToDestinationImplCopyWithImpl<T, $Res>
    extends
        _$OnTripStatusStateCopyWithImpl<T, $Res, _$HeadingToDestinationImpl<T>>
    implements _$$HeadingToDestinationImplCopyWith<T, $Res> {
  __$$HeadingToDestinationImplCopyWithImpl(
    _$HeadingToDestinationImpl<T> _value,
    $Res Function(_$HeadingToDestinationImpl<T>) _then,
  ) : super(_value, _then);

  /// Create a copy of OnTripStatusState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$HeadingToDestinationImpl<T> implements _HeadingToDestination<T> {
  const _$HeadingToDestinationImpl();

  @override
  String toString() {
    return 'OnTripStatusState<$T>.headingToDestination()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HeadingToDestinationImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() goForPickup,
    required TResult Function() arrivedAtPickupPoint,
    required TResult Function() rideStarted,
    required TResult Function() headingToDestination,
    required TResult Function() reachedDestination,
    required TResult Function() payment,
  }) {
    return headingToDestination();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? goForPickup,
    TResult? Function()? arrivedAtPickupPoint,
    TResult? Function()? rideStarted,
    TResult? Function()? headingToDestination,
    TResult? Function()? reachedDestination,
    TResult? Function()? payment,
  }) {
    return headingToDestination?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? goForPickup,
    TResult Function()? arrivedAtPickupPoint,
    TResult Function()? rideStarted,
    TResult Function()? headingToDestination,
    TResult Function()? reachedDestination,
    TResult Function()? payment,
    required TResult orElse(),
  }) {
    if (headingToDestination != null) {
      return headingToDestination();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(_GoForPickup<T> value) goForPickup,
    required TResult Function(_ArrivedAtPickupPoint<T> value)
    arrivedAtPickupPoint,
    required TResult Function(_RideStarted<T> value) rideStarted,
    required TResult Function(_HeadingToDestination<T> value)
    headingToDestination,
    required TResult Function(_ReachedDestination<T> value) reachedDestination,
    required TResult Function(_Payment<T> value) payment,
  }) {
    return headingToDestination(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(_GoForPickup<T> value)? goForPickup,
    TResult? Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult? Function(_RideStarted<T> value)? rideStarted,
    TResult? Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult? Function(_ReachedDestination<T> value)? reachedDestination,
    TResult? Function(_Payment<T> value)? payment,
  }) {
    return headingToDestination?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(_GoForPickup<T> value)? goForPickup,
    TResult Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult Function(_RideStarted<T> value)? rideStarted,
    TResult Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult Function(_ReachedDestination<T> value)? reachedDestination,
    TResult Function(_Payment<T> value)? payment,
    required TResult orElse(),
  }) {
    if (headingToDestination != null) {
      return headingToDestination(this);
    }
    return orElse();
  }
}

abstract class _HeadingToDestination<T> implements OnTripStatusState<T> {
  const factory _HeadingToDestination() = _$HeadingToDestinationImpl<T>;
}

/// @nodoc
abstract class _$$ReachedDestinationImplCopyWith<T, $Res> {
  factory _$$ReachedDestinationImplCopyWith(
    _$ReachedDestinationImpl<T> value,
    $Res Function(_$ReachedDestinationImpl<T>) then,
  ) = __$$ReachedDestinationImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$ReachedDestinationImplCopyWithImpl<T, $Res>
    extends
        _$OnTripStatusStateCopyWithImpl<T, $Res, _$ReachedDestinationImpl<T>>
    implements _$$ReachedDestinationImplCopyWith<T, $Res> {
  __$$ReachedDestinationImplCopyWithImpl(
    _$ReachedDestinationImpl<T> _value,
    $Res Function(_$ReachedDestinationImpl<T>) _then,
  ) : super(_value, _then);

  /// Create a copy of OnTripStatusState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ReachedDestinationImpl<T> implements _ReachedDestination<T> {
  const _$ReachedDestinationImpl();

  @override
  String toString() {
    return 'OnTripStatusState<$T>.reachedDestination()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReachedDestinationImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() goForPickup,
    required TResult Function() arrivedAtPickupPoint,
    required TResult Function() rideStarted,
    required TResult Function() headingToDestination,
    required TResult Function() reachedDestination,
    required TResult Function() payment,
  }) {
    return reachedDestination();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? goForPickup,
    TResult? Function()? arrivedAtPickupPoint,
    TResult? Function()? rideStarted,
    TResult? Function()? headingToDestination,
    TResult? Function()? reachedDestination,
    TResult? Function()? payment,
  }) {
    return reachedDestination?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? goForPickup,
    TResult Function()? arrivedAtPickupPoint,
    TResult Function()? rideStarted,
    TResult Function()? headingToDestination,
    TResult Function()? reachedDestination,
    TResult Function()? payment,
    required TResult orElse(),
  }) {
    if (reachedDestination != null) {
      return reachedDestination();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(_GoForPickup<T> value) goForPickup,
    required TResult Function(_ArrivedAtPickupPoint<T> value)
    arrivedAtPickupPoint,
    required TResult Function(_RideStarted<T> value) rideStarted,
    required TResult Function(_HeadingToDestination<T> value)
    headingToDestination,
    required TResult Function(_ReachedDestination<T> value) reachedDestination,
    required TResult Function(_Payment<T> value) payment,
  }) {
    return reachedDestination(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(_GoForPickup<T> value)? goForPickup,
    TResult? Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult? Function(_RideStarted<T> value)? rideStarted,
    TResult? Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult? Function(_ReachedDestination<T> value)? reachedDestination,
    TResult? Function(_Payment<T> value)? payment,
  }) {
    return reachedDestination?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(_GoForPickup<T> value)? goForPickup,
    TResult Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult Function(_RideStarted<T> value)? rideStarted,
    TResult Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult Function(_ReachedDestination<T> value)? reachedDestination,
    TResult Function(_Payment<T> value)? payment,
    required TResult orElse(),
  }) {
    if (reachedDestination != null) {
      return reachedDestination(this);
    }
    return orElse();
  }
}

abstract class _ReachedDestination<T> implements OnTripStatusState<T> {
  const factory _ReachedDestination() = _$ReachedDestinationImpl<T>;
}

/// @nodoc
abstract class _$$PaymentImplCopyWith<T, $Res> {
  factory _$$PaymentImplCopyWith(
    _$PaymentImpl<T> value,
    $Res Function(_$PaymentImpl<T>) then,
  ) = __$$PaymentImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$PaymentImplCopyWithImpl<T, $Res>
    extends _$OnTripStatusStateCopyWithImpl<T, $Res, _$PaymentImpl<T>>
    implements _$$PaymentImplCopyWith<T, $Res> {
  __$$PaymentImplCopyWithImpl(
    _$PaymentImpl<T> _value,
    $Res Function(_$PaymentImpl<T>) _then,
  ) : super(_value, _then);

  /// Create a copy of OnTripStatusState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PaymentImpl<T> implements _Payment<T> {
  const _$PaymentImpl();

  @override
  String toString() {
    return 'OnTripStatusState<$T>.payment()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() goForPickup,
    required TResult Function() arrivedAtPickupPoint,
    required TResult Function() rideStarted,
    required TResult Function() headingToDestination,
    required TResult Function() reachedDestination,
    required TResult Function() payment,
  }) {
    return payment();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? goForPickup,
    TResult? Function()? arrivedAtPickupPoint,
    TResult? Function()? rideStarted,
    TResult? Function()? headingToDestination,
    TResult? Function()? reachedDestination,
    TResult? Function()? payment,
  }) {
    return payment?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? goForPickup,
    TResult Function()? arrivedAtPickupPoint,
    TResult Function()? rideStarted,
    TResult Function()? headingToDestination,
    TResult Function()? reachedDestination,
    TResult Function()? payment,
    required TResult orElse(),
  }) {
    if (payment != null) {
      return payment();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial<T> value) initial,
    required TResult Function(_GoForPickup<T> value) goForPickup,
    required TResult Function(_ArrivedAtPickupPoint<T> value)
    arrivedAtPickupPoint,
    required TResult Function(_RideStarted<T> value) rideStarted,
    required TResult Function(_HeadingToDestination<T> value)
    headingToDestination,
    required TResult Function(_ReachedDestination<T> value) reachedDestination,
    required TResult Function(_Payment<T> value) payment,
  }) {
    return payment(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial<T> value)? initial,
    TResult? Function(_GoForPickup<T> value)? goForPickup,
    TResult? Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult? Function(_RideStarted<T> value)? rideStarted,
    TResult? Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult? Function(_ReachedDestination<T> value)? reachedDestination,
    TResult? Function(_Payment<T> value)? payment,
  }) {
    return payment?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial<T> value)? initial,
    TResult Function(_GoForPickup<T> value)? goForPickup,
    TResult Function(_ArrivedAtPickupPoint<T> value)? arrivedAtPickupPoint,
    TResult Function(_RideStarted<T> value)? rideStarted,
    TResult Function(_HeadingToDestination<T> value)? headingToDestination,
    TResult Function(_ReachedDestination<T> value)? reachedDestination,
    TResult Function(_Payment<T> value)? payment,
    required TResult orElse(),
  }) {
    if (payment != null) {
      return payment(this);
    }
    return orElse();
  }
}

abstract class _Payment<T> implements OnTripStatusState<T> {
  const factory _Payment() = _$PaymentImpl<T>;
}
